# 算法基础（三十五）：动态规划 - 计数DP和数位DP

## 计数DP

![](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231105201830409.png)

### 完全背包做法

可以看作是一个背包的容量是`n`，然后有`n`个物品，对应的重量分别是`1 2 3 ....n`，且物品的个数无限，求装满背包的物品选择方案数

因为上述题目中整数`n`的任意一个划分的方案，都可以对应这个背包问题的选法，反之亦然，因此两种做法等价

**变量表示：**

变量维度：一个两维变量`f[i, j]`

变量对应集合：所有从`1 ~ i`中选择并且体积为`j`的选法构成的集合

变量属性：集合中元素的个数

**集合划分与状态计算：**

跟完全背包问题的划分方式一样，对当前物品`i`选了多少个进行划分：

`0`个：`f[i, j] = f[i - 1, j]`

`1`个：`f[i, j] = f[i - 1, j - i]`

`2`个：`f[i, j] = f[i - 1, j - 2 * i]`

...

`s`个：`f[i, j] = f[i - 1, j - s * i]`

最后加起来即可，代码这里就不写了

**时间复杂度：**

一共最多`n^2`个状态，最后的时间复杂度看似是`n^3`，但是再仔细分析一下

```cpp
for(int i = 1; i <= n; i ++)
    for(int j = i; j <= n; j ++)
        f[i][j]......
```



当计算`f[i, j]`的时候，需要计算最多$\frac{j}{i}$次，最外层`i`固定循环`j`的时候计算的次数是$\Sigma_{j = 1}^{n} \frac{j}{i} = \frac{1}{i}(1 + 2 + ...n)$

再进行最外层的循环得到总的计算次数为$(1 + 2 + ...n)\Sigma_{i = 1}^{n} \frac{1}{i}$

最后的复杂度应该是`O(n^2logn)`

**代码实现：**

```cpp
// f[i][j] = f[i - 1][j] + f[i][j - i]
#include <iostream>

using namespace std;

const int N = 1e3 + 7, mod = 1e9 + 7;

int f[N][N];

int main() {
    int n;
    cin >> n;

    for (int i = 0; i <= n; i ++) {
        f[i][0] = 1; // 容量为0时，前 i 个物品全不选也是一种方案
    }

    for (int i = 1; i <= n; i ++) {
        for (int j = 0; j <= n; j ++) {
            f[i][j] = f[i - 1][j] % mod; // 特殊 f[0][0] = 1
            if (j >= i) f[i][j] = (f[i - 1][j] + f[i][j - i]) % mod;
        }
    }

    cout << f[n][n] << endl;
}
```

**代码优化：**

`f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2i] + ..... + f[i - 1][j - i * s]`(s是满足i*s <= j的最大值)
`f[i][j - i] = f[i - 1][j - i] + f[i - 1][j - 2i] + ..... + f[i - 1][j - i * s] `

因此可以优化为`f[i][j] = f[i - 1][j] + f[i][j - i]`

同时可以去掉第一维得到：`f[j] = f[j] + f[j - i]`

枚举体积的时候从小到大进行循环，这样等式右边的`f[j]`还未更新，值是上一层的`f[i - 1][j]`，且等式右边的`f[j - i]`用的是更新过的值也就是本层的`f[i][j - i]`

**优化版本代码实现：**

