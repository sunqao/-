# 算法基础（三十七）：动态规划 - 树形DP

例题如下：

![image-20231129214724863](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231129214724863.png)

![image-20231129214743598](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231129214743598.png)

**状态表示：**

变量维度：树形DP，这里用两个变量`f[u, 0]`和`f[u, 1]`

变量对应集合：`f[u, 0]`对应的集合为所有从以`u`为根的子树中选择，不选`u`的方案的快乐指数构成的集合，`f[u, 1]`对应的集合为所有从以`u`为根的子树中选择，选`u`的方案的快乐指数构成的集合

变量属性：集合的最大值

**状态计算与集合划分：**

我们以下图为例来说明：

![image-20231129215316542](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231129215316542.png)

在计算`f[u, 0]`的时候它对应的集合可以根据它的子节点`s1, s2`划分为四类，选或不选`s1`的方案，选或不选`s2`的方案，当然这个划分可能有重复，不过不影响，且这四类的最大值分别为`f[s1, 0], f[s1, 1], f[s2, 0], f[s2, 1]`，这里因为不选`u`，这时的方案肯定要两个子树都最大并且加起来，因此`f[u, 0] = Max(f[s1, 0], f[s1, 1]) + Max(f[s2, 0], f[s2, 1]) `

同理，`f[u, 1]`表示选择了点`u`，因为不会有下属愿意和直接上司一起参加，所以`f[u, 1] = f[s1, 0] + f[s2, 0] + a[u]`，`a[u]`表示点`u`的快乐值

这样最后的结果就是`Max(f[root, 0], f[root, 1])`

当然每个结点不一定只有两个儿子，所以将公式统一就是：

$f[u, 0] = \Sigma Max(f[si, 0], f[si, 1])$

$f[u, 1] = \Sigma Max(f[si, 0])$

**时间复杂度：**

一个有`n`个节点，我们每个点需要枚举两次，每次需要枚举它的所有的儿子，所有节点的儿子数量是`n - 1`，因此一共枚举了`2(n - 1)`次，时间复杂度是`O(n)`

**代码实现：**

