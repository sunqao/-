# 算法基础（二十九）：数学基础 - 博弈论 - Nim游戏

**公平组合游戏定义：**

如果一个游戏满足：

- 由两名玩家交替行动
- 在游戏进行的任意时刻，可以执行的合法行动与轮到哪位玩家无关
- 不能行动的玩家判负

那么我们就称这个游戏为一个公平组合游戏，尼姆游戏`(NIM)`属于公平组合游戏，但常见的棋类游戏，比如围棋就不是公平组合游戏,因为不能满足第二条和第三条

**问题举例：**

![image-20230322192421052](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20230322192421052.png)

**必败状态和必胜状态：**

**必胜状态：**比如先手进行某一个操作，留给后手是一个必败状态时，对于先手来说是一个必胜状态，这时也称为先手必胜状态，也就是说先手**可以走到一个必败状态留给后手**
**必败状态：**先手无论如何操作，留给后手都是一个必胜状态时，对于先手来说是一个必败状态，先手走不到一个必败状态留给后手

**这个问题先说结论：**

如果有`n`堆石子，每堆石子的个数分别为：`a1, a2, a3, a4......an`，若：$a_1 \oplus a_2 \oplus a_3 \oplus a_4......\oplus a_n \ne 0 $则先手必胜，否则先手必输

**下面来证明：**

- 我们操作到最后的时候有（必败状态）：$0 \oplus 0 \oplus 0 .....0 = 0$
- 若当前的异或和不为`0`即$a_1 \oplus a_2 \oplus a_3 \oplus a_4......\oplus a_n = x \ne 0 $则我们一定可以通过某种方式使他们的异或和变成`0`，也就是说一定可以通过某种方式从某一堆里面拿走若干个石子，让剩下的这些数的异或值变成`0`
	- 假设`x`的二进制表示中最高的一位是第`k`位，那么就说明，`a1 ~ an`中一定至少存在某一个数`ai`它的二进制第`k`位为`1`，如果不存在，那很显然不会出现`x`的第`k`位为`1`
	- 那么就一定会有：$a_i \oplus x < a_i$，因为`x`第`k`位之前的位全为`0`与`ai`进行异或的时候数值不变，但是第`k`位异或后一定变成`0`，所以结果会减小
	- 于是接下来我们从`ai`这一堆中拿走$a_i - (a_i \oplus x)$这么多的石子，那么此时`ai`这一堆的石子个数就变成了$a_i \oplus x$
	- 那么剩下的所有堆的石子进行异或就是$a_1 \oplus a_2 \oplus a_3 \oplus a_4...\oplus a_i \oplus x...\oplus a_n = x \oplus x = 0 $
- 若当我们遇到$a_1 \oplus a_2 \oplus a_3 \oplus a_4......\oplus a_n = x = 0 $，那么我们无论不管怎么拿，最后得到剩下石子堆进行异或的结果一定不是`0`
	- 假设我们从`ai`中拿了一些石子变成`ai'`使得$a_1 \oplus a_2 \oplus a_3 \oplus a_4..\oplus a_i' \oplus a_{i + 1} ....\oplus a_n = x = 0 $
	- 将$a_1 \oplus a_2 \oplus a_3 \oplus a_4......\oplus a_n = x = 0 $与$a_1 \oplus a_2 \oplus a_3 \oplus a_4..\oplus a_i' \oplus a_{i + 1} ....\oplus a_n = x = 0 $的等式两边分别进行异或，于是我们两两异或消掉可以得到：$a_i \oplus a_{i}' = 0$，但是很显然这两个数是不一样的，所以出现矛盾
	- 所以不管我们怎么拿最后剩下的石子异或的结果一定不是`0`
- **当先手遇到的异或的值不为`0`的话，一定可以拿走一些石子使得后手面对的局面异或值为`0`，且后手不管怎么拿留给先手的异或值必然不为`0`，而由于游戏一定可以结束，从而到最后的时候先手拿走最后一些石子，留给后手无石子可拿，先手必赢**
- **那么反过来，如果先手遇到的异或值为0，则留给后手的异或值一定不是0，后手一定可以拿走一些石子把接下来的异或值为0留给先手，在整个游戏过程中先手遇到的都是异或值为0的状态，到最后先手必输**

## 代码实现

代码及其简单

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int main()
{
    int n;
    int res = 0;
    scanf("%d", &n);
    while(n --)
    {
        int x;
        scanf("%d",&x);
        res ^= x;
    }
    if(res) puts("Yes");
    else puts("No");
    
    return 0;
}
```

