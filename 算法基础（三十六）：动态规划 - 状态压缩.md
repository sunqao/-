# 算法基础（三十六）：动态规划 - 状态压缩DP

**状态压缩DP：**用一个`N`位的二进制数，每一位表示一个物品，`0/1`表示不同的状态。因此可以用`0 → 2^(N − 1)` ( `N` 二 进 制 对 应 的 十 进 制 数 ）中的所有数来枚举全部的状态

## 例题一，蒙德里安的梦想

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231127205655915.png" alt="image-20231127205655915"  />

![image-20231127205706320](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231127205706320.png)

这道题目的意思就是给定一个`m * n`的方格，看能放置多少个`1 * 2`的小方块，我们可以先放横着的小方块，再放竖着的小方块，每一个合法方案一定对应一个放横着的小方块的方案，所以求总的方案数也就等价于求只放横着的小方块的合法方案数，这里的合法指的就是放完横着的小方块之后的剩余位置能否填满竖着的小方块，能即合法

**状态表示：**

变量维度：一个两维变量`f[i, j]`

变量集合：表示前`i - 1`列已经摆好，且从第`i - 1`列的`1*2`小方格伸出到第`i`列的状态为`j`的所有方案，如下图所示，`j`代表一个五位的二进制数，每一位对应大方格中的对应行，为`1`表示第`i - 1`列存在一个横着的`1*2`的小方块延申到了第`i`列：

![image-20231127210906548](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231127210906548.png)

变量属性：集合中元素的个数

**状态计算：**

我们在计算`f[i, j]`的时候从第`i - 1`行延申到第`i`行的`1*2`小方块已经固定，他们的排列状态就是`j`，在这个条件下，我们需要看`i`列前面的列的小方块怎么摆放才合法，这时我们考虑`f[i - 1, k]`，`f[i - 1, k]`表示的是从第`i - 2`列的横着放的小方块延申到第`i - 1`列的状态为`k`的合法方案数

考虑`f[i, j]`的某个合法方案的特征，由于从第`i - 1`行延申到第`i`行的`1*2`小方块的排列状态已经固定，所以这个合法方案从第`i - 2`行延申到第`i - 1`行的`1*2`小方块的排列状态`k`一定满足：

1. `k`与`j`不冲突，即`(k & j == 0)`，如果`k, j`存在某一行冲突的话就会出现下图所示的非法方案，由题意，不能出现连续的三个小方格：

![image-20231127213220322](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231127213220322.png)

2. 第`i - 1`列连续空着的格子一定是偶数，即`(k | j)`不存在连续奇数个`0`，如果是奇数，那么接下来竖着的小格子将无法摆放，也不符合题意

所以在计算`f[i, j]`的时候，只要`i - 1`列之前的某个合法方案（`f[i - 1, k]`对应集合中的某个元素）的第`i - 2`延申到第`i - 1`列的小方格的摆放状态满足上面两个条件，那么这个合法方案也一定能转移成第`i`列的合法方案，也就是`f[i, j]`对应的集合中的一个元素

同理`f[i, j]`的集合中的一个合法方案，他的第`i - 2`列延申到第`i - 1`列的小方格的摆放也一定满足上面两个性质

因此，我们只需计算出`f[i - 1, k]`对应集合中所有满足上面两条性质的元素个数即可

即$f[i, j] = \Sigma_{k = 00000}^{k = 11111}f[i - 1, k]$，其中`k`满足:`(k & j) == 0`且`(k | j)`不存在连续奇数个`0`

**时间复杂度：**

假设大方格为`m * n`，一共`n`列，每一列都需要枚举`2^m`次状态，同时计算某一列的某个状态时要枚举前面一列的`2^m`个状态，因此时间复杂度为`O(n * 2^(2m))`

**代码实现：**

```cpp
 #include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 12, M = 1 << N;//M是2^N

int n, m;

long long f[N][M];//变量

//st[i] = false表示i的二进制中存在连续奇数个零
bool st[M];

int main(){
    int n, m;
    
    //当一直有数输入，且n和m都不为零的时候
    while(cin >> n >> m, n || m){
        //将f初始化为0
        memset(f, 0, sizeof f);
        //先预处理所有的状态i的二进制位是不是不存在连续奇数个零
        for(int i = 0; i < 1 << n; i ++){
            st[i] = true;
            int cnt = 0;//cnt表示当前状态连续零的个数
            //j用来判断状态i的第j行是否放置了小方块也就是状态i的第j位是否为1
            for(int j = 0; j < n; j ++){
                if( i >> j & 1){
                    //如果状态i的第j行放置了小方块
                    //说明此时cnt的值代表状态i的某一段连续零的个数
                    if(cnt & 1) st[i] = false;//如果状态i存在连续奇数个零，说明此时这个状态i不合法
                    cnt = 0;//这一段连续的零计算结束，cnt清零
                    
                }else{
                    cnt ++;
                }
            }
            //判断状态i的二进制没有遇到1，最后一段零的个数
            if(cnt & 1) st[i] = false;
        }
        
        //开始DP，初始情况特殊化处理，赋值为1
        //这里赋值为1并没有特殊含义
        //只是计算f[1][x]的时候会遍历f[0][0 ~ 2^n]
        //f[0][1 ~ 2^n]不用多说根据定义都是0
        //遍历f[0][0]的时候x | 0也就表示x本身，如果x本身没有连续奇数个0此时f[1][x] = 1
        //即f[1][x] += f[0][0]
        //这里赋值为1只是为了后面的处理方便
        f[0][0] = 1;
        
        //其实应该单独处理f[1][x]的，单独处理边界思路更加清晰
        
        //枚举每一列，一直枚举到第m列，注意存在第零列，且题目中只有m列
        //我们多算了一列，方便计算结果
        for(int i = 1; i <= m; i ++)
            //枚举每一列的不同状态
            for(int j = 0; j < 1 << n; j ++)
                //枚举第i - 1列的不同状态
                for(int k = 0; k < 1 << n; k ++)
                    //开始判断条件
                    //只有不冲突，且连续空的行不是奇数的时候才能构成合法方案
                    if((j & k) == 0 && st[j | k])
                        f[i][j] += f[i - 1][k];
                
        
        //最后的答案是f[m][0]
        //表示第m - 1列不存在延申到第m列的小方格放置状态
        cout << f[m][0] << endl;
    }
    
    return 0;
}
```

## 例题二，最短Hamilton路径

![image-20231128211046657](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231128211046657.png)

如果这道题目暴力来做的话，顶点的序列排列是`n!`个，计算长度的话是`n`，因此时间复杂度是`O(n!*n)`，显然超时，不可取，因此这道题目需要用状态压缩DP来求解

**状态表示：**

变量维度：一个二维变量`f[i, j]`

变量对应集合：从`0`走到终点`j`，走过的所有的点构成状态是`i`的路径长度构成的集合，比如`i = 1110011`，表示第`0，1，4，5，6`个点走过，`2, 3`没有走过，这些经过的点的不同顺序有不同的长度路径

变量属性：集合的最小值

**集合划分与状态计算：**

`f[i, j]`对应的集合为：从`0`走到终点`j`，走过的所有的点构成状态是`i`的路径长度构成的集合，我们以经过的倒数第二个点来进行分类，倒数第二个点可以取`0 ~ n - 1`个点，如下图所示：

![image-20231128213300694](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231128213300694.png)

假设倒数第二个点是`k`，那么路径就是：`0....-> k -> j`，由于`k -> j`的路径值固定，所以要`0....-> k`最短，由于`0...k, j`这些点构成的状态是`i`，因此`0....k`构成的状态是`i`除去`j`的状态，记为`i - {j}`，因此`0 ..... -> k`的最短值就是`f[i - {j}][k]`，表示从第`0`个点走到第`k`个点，经过的点的状态构成为`i - {j}`的最短路径，因此倒数第二个点是第`k`个点的最短路径就是`f[i - {j}][k] + a[k][j]`，`a[k][j]`表示`k -> j`的长度

最后`f[i, j]`遍历所有`k`取最小值即可

**集合存在性问题：**

`f[i, j]`，从`0`走到`j`，状态`i`中必须包含`j`，否则`f[i, j]`没有意义，值为正无穷 

其次，`i - {j}`只有包含了第二个点才算有意义，否则这个子集不存在，值为正无穷

**边界问题：**

`f[0][x] = 正无穷`

`f[x][0]`，`f[1][0] = 0`，其他的正常计算即可

剩下的都可以通过递推求解 

**两个问题：**

1. 为什么最后的结果一定是`Hamilton`路径？

因为我们的计算过程是这样的，假设计算得到`f[i, j] = m`的时候中间有一个点`k`走了多次，假设`f[i1, k]`是最后一次走到点`k`的状态，根据计算，上一步找`f[i1 - {k}, k']`的最小值，显然`i1 - {k}`不包含走`k`的状态，`k`不能可走两次，因此计算得到的`f[i, j] = m`一定是`Hamilton`

2. 注意计算`f[i, j]`的时候，若状态`i`的第零位为`0`，则表示`f[i, j]`为正无穷

从定义可以理解，同时在计算的过程中也可以理解，如果`i`的第`0`位为`0`，则一步步剔除的时候一定会剔除到`f[i1, k]`其中`i1`只有第`k`位为`1`的状态，此时再进一步剔除，最后一定是正无穷，因此初始化的时候只有`f[1][0] = 0`表示终点为`0`的时候不用走，并且`f[x][0]`除了`f[1][0] = 0`之外其他的都为正无穷，所有存在结果的路径最终一定会剔除到`f[1][0]`

**代码实现：**

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 20, M = 1 << N;

int n;
int w[N][N];//w表示两点之间的距离

int f[M][N];//M表示状态，一共最多二十位

int main(){
    cin >> n;
    
    //处理输入
    for(int i = 0; i < n; i ++)
        for(int j = 0; j < n; j ++)
            cin >> w[i][j];
    
    //先将所有的变量初始化为正无穷
    memset(f, 0x3f, sizeof f);
    //初始化，从第0个点走到第0个点
    f[1][0] = 0;
    
    //开始计算从状态0开始枚举
    for(int i = 0; i < 1 << n; i ++)
        for(int j = 0; j < n; j ++)
            if(i >> j & 1) //只有状态i中经过了点j才有意义
                //开始计算，枚举倒数第二个点
                for(int k = 0; k < n; k ++)
                    //同上，只有i - {j}包含k，才有意义
                    if((i - (1 << j)) >> k & 1)
                        f[i][j] = min(f[i - (1 << j)][k] + w[k][j], f[i][j]);
                        
    
    // (1<<n) - 1即2^n - 1，表示从0到n - 1个点全都走了一遍
    cout << f[(1 << n) - 1][n - 1] << endl;
    
    return 0;
    
}
```

**时间复杂度：**

显然为`O(2^n * n^2)`其中`n`为顶点的个数

