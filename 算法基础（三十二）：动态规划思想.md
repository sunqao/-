# 算法基础（三十二）：用01背包为例来分析动态规划

我们以`0 1`背包问题来总结动态规划的一般流程：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20230401204315657.png" alt="image-20230401204315657" style="zoom:50%;" />

总的来说`dp`问题包括这三大部分：

**状态表示：**

也就是一个未知数，思考用**几维**来表示我们需要解决的问题，背包问题一般是两维：`f[i, j]`

**状态计算：**

我们如何一步步将我们的状态计算出来，即如何算出我们的`f[i, j]`

**DP优化：**

一般是对动态规划的代码或者是方程进行等价变形，一般是先写出最基本的形式，然后再进行优化 

![image-20230401215241421](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20230401215241421.png)

接下来我们来思考这个未知数的含义是什么，未知数的含义一般有两层，第一是未知数对应的集合是什么，第二是这个未知数的值表示的是这个集合中的哪个属性：

**状态对应的集合：**

一般而言，每一个状态未知数都对应着一堆数值，这些数值在一起表示的是整个集合，比如**在背包问题中`f[i, j]`就对应的是一堆选法对应价值的集合，这些选法满足的条件是：物品的编号不超过`i`，物品的体积不超过`j`**

**集合的属性：**

这个未知数存的数其实就是它对应集合的某个属性，常见的属性有最大值，最小值，集合元素数量，在背包问题中，`f[i, j]`的值表示的就是集合的最大值

然后就是状态计算，我们在这里用集合划分的方式来进行计算

**集合划分：**

 如何将当前集合划分成若干个更小子集，使得每一个子集我们都可以算出来，对于背包问题来说我们可以将这个状态对应的集合划分成两类：不包含第`i`个物品选法对应的价值以及包含第`i`个物品对应的价值，划分如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20230401212716065.png" alt="image-20230401212716065" style="zoom:50%;" />

**集合的划分也有两个标准：**

- 不重复，集合中的某个元素必须只能属于划分的子集中的一个，但是这个原则不一定需要必须满足
- 不漏，集合中的某个元素必须属于划分的子集中的一个

**然后再看每一个子集的表示**

对于上面划分左边的子集，它的意思就是已经选了第`i`个物品，然后在剩下的物品中选择对应的价值集合，很显然不管怎样都含有第`i`个物品的价值，那么我们剩下只能从`1 ~ i - 1`个物品中选择，并且由于已经选择了第`i`个物品，背包的剩下空间就是`j - vi`，于是这个集合对应的未知数表示就是`wi + f[i-1, j-vi]`；

对于右半边的集合，它的表示就是从`1 ~ i - 1`个物品中选物品，体积不超过`j`的选法对应的价值，那么这个集合它对应的未知数就是`f[i-1, j]`

**最后得到递推公式：**

很显然，`f[i, j]`的值就是左右两个集合取最大，即`f[i, j] = max(wi + f[i-1, j-vi], f[i-1, j])`

### 代码实现

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1010;
//n表示所有物品的个数
//m表示背包的容积
int n, m;
//v[i]表示物品i的体积，w[i]表示物品i的价值
int v[N], w[N];

//f[i][j]表示状态
int f[N][N];

int main()
{
    //读入物品个数和背包容量
    cin >> n >> m;
    
    //读入所有的物品体积和价值
    for(int i = 1; i <= n; i ++) cin >> v[i] >> w[i];
    
    //i = 0的所有价值都为0，不用计算
    //j = 0的所有价值都为0，不用计算
    for(int i = 1; i <= n; i ++) 
        for(int j = 0; j <= m; j ++)
        {
            //先默认取不装入第i个物品的情况。后面再作比较
            f[i][j] = f[i - 1][j];
            //对于装入第i个物品的情况，只有背包的体积大于这个物品时才能装入，否则这个情况就是一个空集
            //这种情况取的是不装入第i个物品
            if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
        }
    
    cout << f[n][m] << endl;
    
    return 0;
}
```

## 代码优化

首先我们看到这个递推公式：

```cpp
//先默认取不装入第i个物品的情况。后面再作比较
f[i][j] = f[i - 1][j];
//对于装入第i个物品的情况，只有背包的体积大于这个物品时才能装入，否则这个情况就是一个空集
//这种情况取的是不装入第i个物品
if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
```

我们以`i`作为层数，我们可以发现在计算第`i`层的`f[i][j]`的时候我们只使用的第`i - 1`层的`j`，所以我们其实可以只用一维的数组`f[j]`，当计算完第`i`层的`f[j]`之后，进入第`i + 1`层时，此时的`f[j]`仍然是第`i`层的值，我们直接对`f[j]`使用自己的值进行改变，变成第`i + 1`层

```cpp
    for(int i = 1; i <= n; i ++) 
        for(int j = 0; j <= m; j ++)
        {
            //不装入第i个物品的情况
            f[j] = f[j];
            //对于装入第i个物品的情况，只有背包的体积大于这个物品时才能装入，否则这个情况就是一个空集
            //这种情况取的是不装入第i个物品
            //if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
            if(j >= v[i]) f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
```

由于`j`是从小到大开始遍历，所以当计算到`j = k`的时候使用的值是`f[j - v[i]]`，其中`j - v[i]`一定是小于`k`的，也就说明`f[j - v[i]]`在之前已经更新过，说明此时使用的`f[j - v[i]]`不是原来的`i - 1`层的值，所以还需要进行进一步更改，那么此时我们`j`从后往前遍历即可：

```cpp
    for(int i = 1; i <= n; i ++) 
        for(int j = m; j >= 0; j --)
        {
            //f[i][j] = f[i - 1][j];
            f[j] = f[j];
            //if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
            if(j >= v[i]) f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
```

进一步将`if`语句进行优化可得：

```cpp
    for(int i = 1; i <= n; i ++) 
        for(int j = m; j >= v[i]; j --)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
```

我们以一个二维的矩阵图可以更加清晰看到这个优化过程，优化之前的图如下所示，在最开始的时候是从左往右，从上往下依次计算`f[i][j]`的值，`f[i,j]`的值只取决于上一层已经计算完成的值，如下图中上一层的蓝色和棕色的方框所示，`f[i, j]`是两者取大的结果，并且如果`j < v[i]`棕色框是没有值的，也就是上文中的空集的情况，这时`f[i, j]`取为蓝色框中的值：

![动态规划](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.jpg)因此，我们将二维优化到一维的时候：

```c++
for(int i = 1; i <= n; i ++) 
    for(int j = 0; j <= m; j ++)
    {
        //不装入第i个物品的情况
        f[j] = f[j];
        //对于装入第i个物品的情况，只有背包的体积大于这个物品时才能装入，否则这个情况就是一个空集
        //这种情况取的是不装入第i个物品
        //if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
        if(j >= v[i]) f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
```

由于`i`是从小到大遍历，当计算`i + 1`层的时候此时`f[j]`以及`f[j - v[i + 1]]`的值仍然是第`i`层的结果，所以直接使用这两个值再计算`i + 1`层的`f[j]`是与上面的二维计算过程完全等价的

但是同时我们注意到，由于我们遍历`j`的时候是从左往右遍历的，如下图所示，左边的`f[j-v[i]]`是第`i`层已经计算过的值，所以不再是第`i - 1`层的值，因此从左往右遍历计算的结果是不对的：

![绘图1(1)](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/%E7%BB%98%E5%9B%BE1(1).jpg)

这时因为第`i`层的计算结果仅仅取决于第`i - 1`层跟遍历顺序无关，所以我们遍历的时候可以从右往左遍历这时`f[j-v[i]]`仍是上一层的值，因此计算更新的`f[j]`值正确：

```c
for(int i = 1; i <= n; i ++) 
    for(int j = m; j >= 0; j --)
    {
        //f[i][j] = f[i - 1][j];
        f[j] = f[j];
        //if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
        if(j >= v[i]) f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
```

以上就是动态规划的一般处理思想
