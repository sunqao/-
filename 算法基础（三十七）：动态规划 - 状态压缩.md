# 算法基础（三十七）：动态规划 - 状态压缩DP

**状态压缩DP：**用一个`N`位的二进制数，每一位表示一个物品，`0/1`表示不同的状态。因此可以用`0 → 2^(N − 1)` ( `N` 二 进 制 对 应 的 十 进 制 数 ）中的所有数来枚举全部的状态

**例题：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231127205655915.png" alt="image-20231127205655915"  />

![image-20231127205706320](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231127205706320.png)

这道题目的意思就是给定一个`m * n`的方格，看能放置多少个`1 * 2`的小方块，我们可以先放横着的小方块，再放竖着的小方块，每一个合法方案一定对应一个放横着的小方块的方案，所以求总的方案数也就等价于求只放横着的小方块的合法方案数，这里的合法指的就是放完横着的小方块之后的剩余位置能否填满竖着的小方块，能即合法

**状态表示：**

变量维度：一个两维变量`f[i, j]`

变量集合：表示前`i - 1`列已经摆好，且从第`i - 1`列的`1*2`小方格伸出到第`i`列的状态为`j`的所有方案，如下图所示，`j`代表一个五位的二进制数，每一位对应大方格中的对应行，为`1`表示第`i - 1`列存在一个横着的`1*2`的小方块延申到了第`i`列：

![image-20231127210906548](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231127210906548.png)

变量属性：集合中元素的个数

**状态计算：**

我们在计算`f[i, j]`的时候从第`i - 1`行延申到第`i`行的`1*2`小方块已经固定，他们的排列状态就是`j`，在这个条件下，我们需要看`i`列前面的列的小方块怎么摆放才合法，这时我们考虑`f[i - 1, k]`，`f[i - 1, k]`表示的是从第`i - 2`列的横着放的小方块延申到第`i - 1`列的状态为`k`的合法方案数

考虑`f[i, j]`的某个合法方案的特征，由于从第`i - 1`行延申到第`i`行的`1*2`小方块的排列状态已经固定，所以这个合法方案从第`i - 2`行延申到第`i - 1`行的`1*2`小方块的排列状态`k`一定满足：

1. `k`与`j`不冲突，即`(k & j == 0)`，如果`k, j`存在某一行冲突的话就会出现下图所示的非法方案，由题意，不能出现连续的三个小方格：

![image-20231127213220322](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231127213220322.png)

2. 第`i - 1`列连续空着的格子一定是偶数，即`(k | j)`不存在连续奇数个`0`，如果是奇数，那么接下来竖着的小格子将无法摆放，也不符合题意

所以在计算`f[i, j]`的时候，只要`i - 1`列之前的某个合法方案（`f[i - 1, k]`对应集合中的某个元素）的第`i - 2`延申到第`i - 1`列的小方格的摆放状态满足上面两个条件，那么这个合法方案也一定能转移成第`i`列的合法方案，也就是`f[i, j]`对应的集合中的一个元素

同理`f[i, j]`的集合中的一个合法方案，他的第`i - 2`列延申到第`i - 1`列的小方格的摆放也一定满足上面两个性质

因此，我们只需计算出`f[i - 1, k]`对应集合中所有满足上面两条性质的元素个数即可

即$f[i, j] = \Sigma_{k = 00000}^{k = 11111}f[i - 1, k]$，其中`k`满足:`(k & j) == 0`且`(k | j)`不存在连续奇数个`0`

**时间复杂度：**

假设大方格为`m * n`，一共`n`列，每一列都需要枚举`2^m`次状态，同时计算某一列的某个状态时要枚举前面一列的`2^m`个状态，因此时间复杂度为`O(n * 2^(2m))`

**代码实现：**

```cpp
 #include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 12, M = 1 << N;//M是2^N

int n, m;

long long f[N][M];//变量

//st[i] = false表示i的二进制中存在连续奇数个零
bool st[M];

int main(){
    int n, m;
    
    //当一直有数输入，且n和m都不为零的时候
    while(cin >> n >> m, n || m){
        //将f初始化为0
        memset(f, 0, sizeof f);
        //先预处理所有的状态i的二进制位是不是不存在连续奇数个零
        for(int i = 0; i < 1 << n; i ++){
            st[i] = true;
            int cnt = 0;//cnt表示当前状态连续零的个数
            //j用来判断状态i的第j行是否放置了小方块也就是状态i的第j位是否为1
            for(int j = 0; j < n; j ++){
                if( i >> j & 1){
                    //如果状态i的第j行放置了小方块
                    //说明此时cnt的值代表状态i的某一段连续零的个数
                    if(cnt & 1) st[i] = false;//如果状态i存在连续奇数个零，说明此时这个状态i不合法
                    cnt = 0;//这一段连续的零计算结束，cnt清零
                    
                }else{
                    cnt ++;
                }
            }
            //判断状态i的二进制没有遇到1，最后一段零的个数
            if(cnt & 1) st[i] = false;
        }
        
        //开始DP，初始情况特殊化处理，赋值为1
        //这里赋值为1并没有特殊含义
        //只是计算f[1][x]的时候会遍历f[0][0 ~ 2^n]
        //f[0][1 ~ 2^n]不用多说根据定义都是0
        //遍历f[0][0]的时候x | 0也就表示x本身，如果x本身没有连续奇数个0此时f[1][x] = 1
        //即f[1][x] += f[0][0]
        //这里赋值为1只是为了后面的处理方便
        f[0][0] = 1;
        
        //其实应该单独处理f[1][x]的，单独处理边界思路更加清晰
        
        //枚举每一列，一直枚举到第m列，注意存在第零列，且题目中只有m列
        //我们多算了一列，方便计算结果
        for(int i = 1; i <= m; i ++)
            //枚举每一列的不同状态
            for(int j = 0; j < 1 << n; j ++)
                //枚举第i - 1列的不同状态
                for(int k = 0; k < 1 << n; k ++)
                    //开始判断条件
                    //只有不冲突，且连续空的行不是奇数的时候才能构成合法方案
                    if((j & k) == 0 && st[j | k])
                        f[i][j] += f[i - 1][k];
                
        
        //最后的答案是f[m][0]
        //表示第m - 1列不存在延申到第m列的小方格放置状态
        cout << f[m][0] << endl;
    }
    
    return 0;
}
```

