# 算法基础（三十七）：动态规划 - 状态压缩DP

**状态压缩DP：**用一个`N`位的二进制数，每一位表示一个物品，`0/1`表示不同的状态。因此可以用`0 → 2^(N − 1)` ( `N` 二 进 制 对 应 的 十 进 制 数 ）中的所有数来枚举全部的状态

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231127205655915.png" alt="image-20231127205655915"  />

![image-20231127205706320](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231127205706320.png)

这道题目的意思就是给定一个`m * n`的方格，看能放置多少个`1 * 2`的小方块，我们可以先放横着的小方块，再放竖着的小方块，每一个合法方案一定对应一个放横着的小方块的方案，所以求总的方案数也就等价于求只放横着的小方块的合法方案数，这里的合法指的就是放完横着的小方块之后的剩余位置能否填满竖着的小方块，能即合法

**状态表示：**

变量维度：一个两维变量`f[i, j]`

变量集合：表示前`i - 1`列已经摆好，且从第`i - 1`列的`1*2`小方格伸出到第`i`列的状态为`j`的所有方案，如下图所示，`j`代表一个五位的二进制数，每一位对应大方格中的对应行，为`1`表示第`i - 1`列存在一个横着的`1*2`的小方块延申到了第`i`列：

![image-20231127210906548](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231127210906548.png)

变量属性：集合中元素的个数

**状态计算：**

我们在计算`f[i, j]`的时候从第`i - 1`行延申到第`i`行的`1*2`小方块已经固定，他们的排列状态就是`j`，在这个条件下，我们需要看`i`列前面的列的小方块怎么摆放才合法，这时我们考虑`f[i - 1, k]`，`f[i - 1, k]`表示的是从第`i - 2`列的横着放的小方块延申到第`i - 1`列的状态为`k`的合法方案数

考虑`f[i, j]`的某个合法方案的特征，由于从第`i - 1`行延申到第`i`行的`1*2`小方块的排列状态已经固定，所以这个合法方案从第`i - 2`行延申到第`i - 1`行的`1*2`小方块的排列状态`k`一定满足：

1. `k`与`j`不冲突，即`(k & j == 0)`，如果`k, j`存在某一行冲突的话就会出现下图所示的非法方案，由题意，不能出现连续的三个小方格：

![image-20231127213220322](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231127213220322.png)

2. 第`i - 1`列连续空着的格子一定是偶数，即`(k | j)`不存在连续奇数个`0`，如果是奇数，那么接下来竖着的小格子将无法摆放，也不符合题意

所以在计算`f[i, j]`的时候，只要`i - 1`列之前的某个合法方案（`f[i - 1, k]`对应集合中的某个元素）的第`i - 2`延申到第`i - 1`列的小方格的摆放状态满足上面两个条件，那么这个合法方案也一定能转移成第`i`列的合法方案，也就是`f[i, j]`对应的集合中的一个元素

同理`f[i, j]`的集合中的一个合法方案，他的第`i - 2`列延申到第`i - 1`列的小方格的摆放也一定满足上面两个性质

因此，我们只需计算出`f[i - 1, k]`对应集合中所有满足上面两条性质的元素个数即可

即$f[i, j] = \Sigma_{k = 00000}^{k = 11111}f[i - 1, k]$，其中`k`满足:`(k & j) == 0`且`(k | j)`不存在连续奇数个`0`

**时间复杂度：**

假设大方格为`m * n`，一共`n`列，每一列都需要枚举`2^m`次状态，同时计算某一列的某个状态时要枚举前面一列的`2^m`个状态，因此时间复杂度为`O(n * 2^(2m))`

**代码实现：**

```cpp
 
```

