# 算法基础（四十四）：时空复杂度分析

## 一些基本概念：

我们需要明确一个概念，`C++`每秒可以计算`10^7 ~ 10^8`次，因此对于时间限制在`1s`的题目，我们就需要将算法优化到可以计算`10^7`左右，这样才能通过评测，如果计算次数超过了`10^8`次，如果常数不是特别小的话就一定会超时

因此，我们可以通过题目中的数据范围来反推应该使用什么样的算法，比如当题目的范围小于30的时候我们可以直接使用暴力搜索，哪怕是指数级别的复杂度也可以将计算次数控制在`10^7 ~ 10^8`以内，根据不同的范围，总结的应该使用的算法如下图所示：

![image-20231216125312287](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231216125312287.png)

另外有一个近似的约等于是`log2(10^x)`近似等于`3x`

## 分析代码的时间复杂度

最简单的循环，一重就是`n`，二重就是n*n，这里不再多说，提一嘴，这里在DP中比较常见，尤其是线性DP

**递归分析**

 一般而言，可以用主定理来分析递归程序的复杂度，但是这种做法很麻烦而且不适用，我们一般都是按每层单独分析，最后看有多少层，比如归并和快排，平均下来一共有`log(n)`层，每层计算`n`次，所有时间复杂度就是`nlog(n)`

**双指针**

注意有些双指针算法虽然看似是两重循环，但是内层循环其实经过分析最多执行`n`次，不能简单按照双循环乘起来计算，比如下方的代码：

```cpp
for(int i = 0, j = 0; i < n; i++){
    while(j < i && check(i, j)){
        j++;
    }
    //剩下是每道题的具体逻辑
}
```

`i`每次增加进入`for`循环，然后`j`总会移动到`i`，所以看似两重循环其实内存只运行了`n`次，同时还有`KMP`算法的片段：

```cpp
for(int i = 1, j = 0; i <= m; i++){
        while(j && s[i] != p[j + 1]) j = ne[j];//不相等，递归跳过一定失败的尝试，回退，重新匹配
        //跳出while循环时若j = 0，则表示回退到了起点，重新匹配
        if(s[i] == p[j + 1]){
            j++;//满足相等的话，继续向后尝试，若不满足，则直接i++,进行新一轮的尝试
        }
        if(j == n){
            //匹配成功
            printf("%d ", i - n);//我们存数组是从1开始，但是题目中输出是从0开始，所以不+1
            //目标串可能包含多个模板串，需要反复匹配
            j = ne[j];//j 不能从0开始匹配，因为前面匹配成功的串中记录了信息，需要回退到ne[j]
        }
        
    }
```

同样是看似两重循环，但是首先是`for`循环，最多循环`m`次，对于`j++`这行代码，每次最多加一次，所以在这`m`次循环中，`j`最多加上`m`.下面再看其中的`while`循环。`while`循环的功能就是把`j`往回跳，而由于最后`j >= 0`所以，在`m`次`for`循环中，`j`最多回跳了`m`次，所以总的复杂度最多是`O(2m)`也就是`O(m)`

**搜索与图论**

这种题目虽然递归函数很多，但是分析时间复杂度的时候一般直接数计算量即可，一般是一个树形的结构，我们直接计算树的结点的个数即可，另外图论也是这样想的，我们需要思考算法遍历了哪些东西，是边还是结点，然后想这些东西的个数即可

**动态规划**

动态规划问题的计算量 = 状态数量 * 状态转移的计算量

剩下具体算法的时间复杂度就不一一分析了，还是等到用的时候再说

## 空间复杂度

首先先明确`C++`中各种类型的大小：

```cpp
1 Byte(字节) = 8 bit(位)
1 KB= 1024 Byte
1 MB=1024*1024 Byte
1 GB=1024 * 1024 * 1024 Byte
int  4 Byte
char 1 Byte
double, long long   6Byte
bool 1 Byte
```

另外，`Cpp`中的数据都可以通过地址获得，在`64`位的机器中指针的大小就是`8 Byte`，在`32`位的机器中指针的大小就是`4 Byte`

一般的题目要求空间大小都是`64MB`，那么我们来计算一下：

```cpp
64 MB = 64 * 1024 * 1024 Byte = 2^26 Byte = 2^24 个 int
```

因此`64MB`大概可以开`16000000`个`int`，另外我们的数组空间不能恰好开到`64MB`，因为程序本身还会占用内存，我们的数组只能开到`50`多`MB`

另外也可以用`sizeof`来查看开的数组的内存的大小，`sizeof`返回的是`Byte`的个数，除以两个`1024`，返回的是`MB`：

```cpp
int a[N];
int b[N];
int c[N];
const int N = 1000010;
cout << (sizeof a + sizeof b + sizeof v) / 1024 / 1024 << endl;

结果是11MB的空间
```

另外如果开的数组大小大于`64MB`但是一般也不会爆内存，因为操作系统会进行优化，因为你没有使用，只有你用了操作系统才会分配内存，所以空间复杂度不需要太注意

另外需要注意的是虽然有时我们开的额外数组的空间是`O(1)`，但是如果是递归调用的话还需要系统的空间，比如快速排序需要系统栈，因此空间复杂度也是`O(logn)`的，因为递归了`logn`层
