# 数学归纳法证明Dijkstra算法

**Dijkstra算法：**

有一个非负边的有向图，令集合`S`表示已经确定的从源点出发到这个点最短路的点的集合，令集合`T`表示还未确定的点的集合，令`dist[i]`表示从源点到顶点`i`的距离，初始的时候`dist[i]`中的值是无穷，所有的点都在集合`T`中，`w[x, i]`表示点`x -> i`的权值，我们重复以下步骤：

1. 在集合`T`中找到源点到这个点路径最短的点，也就是`T`中的`dist[i]`最小的点`x`
2. 将这个点`x`放入集合`S`中，并利用这个点更新`T`中的其他的点源点到该点的距离，即`dist[i] = min(dist[i], dist[x] + w[x, i])`
3. 重复以上两个步骤，一直到最后一个点的距离更新完毕

**证明：**

我们需要证明的就是每次从集合`T`中挑出来的点，源点到这个点的距离必然是算法结束后的最短距离，这里使用数学归纳法进行证明：

首先，第一次加入`S`的点`0`，其距离`dist[0] = 0`一定是最短距离，即我们第一次将源点加入到集合，然后更新其余点的距离**（归纳奠基）**

然后，假设根据算法将前`i - 1`个点加入到了集合`S`中，对于前`i - 1`个点的任意一个点`k`，满足`dist[k]`就是它的最短距离**（归纳假设）**

最后，我们来考察从集合`T`中挑出的下一个`dist[i]`最小的点`i`，此时这个点的距离为`dist[i]`，而我们需要证明的是这个`dist[i]`就是源点到点`i`距离最近的距离**（归纳递推）**

我们用反证法来证明：

假设源点到点`i`存在另外一条路线，它的距离满足：`dist[i]' < dist[i] `，那么对于`dist[i]'`这条路线来说，它一定是通过下图到达点`i`：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231214213419684.png" alt="image-20231214213419684" style="zoom:67%;" />

也就是说路线`dist[i]'`一定是先经过了集合`S`，然后经过集合`T`最后到达点`i`，且在集合`S`中的最后一个点`last`不与点`i`直接相接

> 因为对于第`i`个点，它的`dist[i]`是源点只经过集合`S`中的点到达点`i`路径最短的路线
>
> 若此时路线`dist[i]`中点`i`的前驱为`u`如上图所示，也就是说`dist[u] + w[u, i]`一定是`dist[k] + w[k, i]`最短的，其中`k`在`S`中，因为根据我们的算法，在加入前`i - 1`个点的时候假如某一时刻`dist[k] + w[k, i]`不是最短的，那么再加入后面的点`x`时会将`dist[x] + w[x, i]`与`dist[k] + w[k, i]`进行比较从而替换成更短的，所以当算法执行到第`i`个点的时候不存在集合`S`中除了`u`之外的点与`i`直接相连构成的`dist[i]' < dist[i]`了

假设`dist[i]'`这条路线为` 0 -> 1 -> 2....->last -> y -> ....-> i`，那么就有：`dist[y] + w[y,...x] < dist[i]`，由于边权非负，所以有`dist[y] < dist[i]`，这与`dist[i]`是集合`T`中最小的矛盾！所以此时的`dist[i]`就是源点到点`i`的最短距离

证毕。



