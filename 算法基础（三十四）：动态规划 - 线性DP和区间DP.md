# 算法基础（三十四）：动态规划 - 线性DP和区间DP

**线性DP特征：**递推的顺序近似一个线性的顺序

**区间DP的特征：**递推一般从枚举区间的长度开始

**动态规划问题的时间复杂度：**规划的状态数*计算每一个状态需要的计算量

**边界的控制：**一般而言如果状态`i`的计算需要计算用到状态`i - 1`，则循环的下标需要从`1`开始

## 线性DP - 数字三角形

![image-20231026065044686](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231026065044686.png)

**状态表示：**

![image-20231026065538293](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231026065538293.png)

状态表示：一个二维的变量，`f[i, j]`

对应集合：所有从起点走到`i, j`这个位置对应的路径的值

变量对应的属性：所有路径的最大值

**计划划分与状态计算：**

![image-20231026221623428](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231026221623428.png)

`f[i, j] = max(f[i - 1, j - 1] + a[i, j], f[i - 1, j] + a[i, j])`

**代码实现：**

 ```c++
 #include<iostream>
 #include<algorithm>
 using namespace std;
 
 const int N = 510, INF = 1e9;
 
 int n;
 int a[N][N];
 int f[N][N];
 
 int main(){
     scanf("%d", &n);
     for(int i = 1; i <= n; i ++)
         for(int j = 1; j <= i; j ++)
         // 读取三角形的值
             scanf("%d", &a[i][j]);
     
     //为了不处理边界，将所有的f设置为负无穷
     //这样在集合为空的时候得到的值是极小的一个负数，直接可以跳过
     for(int i = 0; i <= n; i ++)
         for(int j = 0; j <= i + 1; j ++)
             f[i][j] = -INF;
     
     //起点为a[1][1]
     f[1][1] = a[1][1];
     
     //从第二行开始计算
     for(int i = 2; i <= n; i ++)
         for(int j = 1; j <= i; j ++)
             f[i][j] = max(f[i - 1][j] + a[i][j], f[i - 1][j - 1] + a[i][j]);
             
             
     //遍历得到结果
     
     int res = -INF;
     
     for(int i = 1; i <= n; i ++) res = max(res, f[n][i]);
     
     cout << res;
     
     return 0;
     
 }
 ```

**时间复杂度：**

状态最多有`n^2`个，计算一次是常数级别，因此，时间复杂度是`n^2`

## 线性DP - 最长上升子序列

![image-20231030211514361](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231030211514361.png)

**状态表示：**

变量表示：一个一维变量，`f[i]`

对应集合：所有以第`i`个数结尾的上升子序列的长度

变量属性：集合的最大值

**集合划分与状态计算：**

以集合中的所有上升子序列的倒数第二个字符的位置进行划分，集合中的所有上升子序列的倒数第二个字符的位置可能在第0个，第1个，，，第`i - 1`个，如下图所示：

![image-20231030213712868](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231030213712868.png)

对于其中一个子集，上升子序列的倒数第二个字符的位置如果是`j`，那么以`j`结尾的最长上升子序列的长度是`f[j]`，而因为这些所有子集的最后一个字符都是第`i`个字符，因此，这个子集的最大值是`f[j] + 1`

因此递推公式为：`f[i] = max(f[j] + 1) j = 0,1,...i - 1`

**集合存在问题：**

只有`a[j] < a[i]`的时候这个子集才存在才能计算最大值，因此当`a[j] >= a[i]`的时候需要跳过

**代码实现：**

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1010;

int n;
int a[N], f[N];

int main(){
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> a[i];
    int res = 0;
    //开始遍历
    for(int i = 1; i <= n; i ++) {
        //f[i] 至少有一个数值，就是字符i本身
        f[i] = 1;
        for(int j = 1; j < i; j ++)
            if(a[j] < a[i]) f[i] = max(f[i], f[j] + 1);
            
        res = max(res, f[i]);
    }
    
    cout << res;
    return 0;
}
```

**注意事项：**

1. 代码的时间复杂度为`O(n^2)`
2. 划分集合的时候不能以是不是`i`结尾来划分集合，注意不要跟连续上升子序列搞混，注意理解变量对应的集合到底是什么
3. 动态规划求递推的时候注意集合的划分用max等操作求值，集合存在问题用if语句求值

**记录路径的版本：**

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1010;

int n;
int a[N], f[N], g[N];

int main(){
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> a[i];
    //resIndex记录，最长上升子序列最后一个字符的下标
    int res = 0;
    //开始遍历
    for(int i = 1; i <= n; i ++) {
        //f[i] 至少有一个数值，就是字符i本身
        f[i] = 1;
        //只有一个字符的情况，g[i]记录以i结尾的最长子序列的倒数第二个字符的位置
        g[i] = 0;
        for(int j = 1; j < i; j ++)
            if(a[j] < a[i])
                if(f[i] < f[j] + 1){
                    f[i] = f[j] + 1;
                    g[i] = j;
                }
            
        if(f[i] > f[resIndex]) resIndex = i;
    }
    //最长长度
    cout << f[resIndex] << endl;
    //最长上升子序列的下标，从后往前
    int index = g[resIndex];
    //一共需要输出最长长度次
    //根据链表的思想，输出地址并将指针指向下一个
    cout << resIndex << " ";
    for(int i = 1; i <= f[resIndex] - 1; i ++){
        cout << index << " ";
        index = g[index];
    }
    
    return 0;
}
```

## 线性DP - 最长上升子序列II

![image-20231104194450401](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231104194450401.png)

与普通的最长上升子序列问题相比是 数据量扩大了，原来的时间复杂度为`O(n^2)`的做法就会超时，现在我们来考虑进行优化，我们以下图的数为例进行分析：

![image-20231104195746727](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231104195746727.png)

**基本原理：**

上图中共有7个数，当我们枚举到第6个数5的时候，对于下标为`1....5`的数字，我们考虑长度为`2`的上升子序列，比如`3, 8`和`1, 2`，对于下标继续从`6`向后枚举形成的子序列，含有`1, 2`的子序列长度一定大于等于含有`3, 8`的子序列的长度，因为`2 < 8`，跟在`8`后面形成的上升序列一定可以跟在`2`的后面

**算法过程与证明：**

归纳假设：

当枚举到第`i`个数的时候，假设：

1. 我们得到了以第`i`个数结尾的最长上升子序列的长度`len`
2. 我们得到了前`i`个数中不同长度的上升子序列结尾的最小的数是哪一个数，这些数按对应的长度递增分别为`a1....aj`，其中`j<= len`，而且下标`1..j`是递增的上升子序列长度序列，且连续

可以证明这些数一定是严格单调递增的，因为假设不是单调递增有`a5 <= a4`，那么对于长度为`5`的这个子序列，因为它是严格增的，因此它的第`4`个数`num`一定有`a54 < a5 < a4`，这样就不能保证长度为`4`的子序列存的数`a4`是最小的了，也就矛盾了

归纳递推：

当枚举第`i + 1`个数`b(i + 1)`的时候，我们已经得到了以`bi`结尾的最长上升子序列的长度`len`，并且得到了前`i`个数不同长度的上升子序列的结尾的最小的值是哪一个数，这些数按对应的长度递增分别为`a1....aj`，其中`j <= len`，我们找到`a1....aj`中小于`b(i + 1)`的最大的那个数，假设是`ak` ，并且有`a(k + 1) >= b(i + 1)`，我们把`b(i + 1)`加到`ak`对应的上升子序列后面，也就是用`b(i + 1)`替换掉`a(k + 1)`，从而保证新的序列也一定是递增的

这时以第`i + 1`个数`b(i + 1)`结尾的最长上升子序列的长度是`len`且`len = k + 1`，证明：

`len`一定是在`1....k...j`这个长度序列的基础上加1，而`k`是它能找到的最大的了，`k`长度后面的序列每个序列的结尾的最小的数都大于等于`b(i + 1)`，肯定不能跟在这些长度的序列后面

归纳奠基：

当枚举第`1`个数的时候，显然以第一个数结尾的最长上升序列的长度就是1，且找到了最小数序列

因此根据上述归纳，枚举到`n`的时候就求出了结果，其实这个题的思想有点像贪心

**代码实现：**

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 100010;

int n;
//用a存所有不同长度下上升子序列结尾的最小值
//下标表示长度
int a[N];
//b来存每一个数
int b[N];

int main(){
    scanf("%d", &n);
    
    for(int i = 0; i < n; i ++){
        scanf("%d", &b[i]);
    }
    
    int len = 0;
    //这里a[0]作为一个哨兵，用来处理枚举到b[i], b[i]是前i个数最小的情况
    //这时需要更新a[1]
    a[0] = -2e9;
    //枚举每一个数
    for(int i = 0; i < n; i ++){
        //二分法找到小于b[i]的最大的那个数
        
        //len作为右边界
        //因为len是上一次枚举得到的最长上升子序列的长度
        //因此a[len]后面的数没意义，因为没有对应长度的子序列
        //所以这一次枚举小于b[i]的最大的数一定是在a[0] ~ a[len]中

        int l = 0, r = len;
        while(l < r){
            int mid = l + r + 1 >> 1;
            
            if(a[mid] < b[i]) l = mid;
            else r = mid - 1;
        }
        //找到小于b[i]的最大的那个数对应的长度r
        //更新此时的最长上升子序列的长度
        len = max(len, r + 1);
        
        a[r + 1] = b[i];
    }
    
    cout << len;
    
    return 0;
    
}
```

**时间复杂度：**

二分的时间复杂度是`log(n)`，因此这里的时间复杂度就是`nlog(n)`



## 线性DP - 最长公共子序列

![image-20231101221237472](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231101221237472.png)

**状态表示：**

变量维度：用一个二维变量`f[i, j]`来表示

表示集合：一个字符串的前`i`个字母和第二个字符串的前`j`个字母中所有公共子序列的长度（所有在第一个字符串前`i`个字母中出现并且在第二个字符串的前`j`个出现的子序列的长度）

变量属性：集合的最大值

**集合划分与状态计算：**

这里的集合划分有些特殊，我们以`a[i], b[j]`是否包含在公共子序列中进行划分，因此上面的集合可以划分为四种，选或者不选`a[i], b[j]`，`0`表示不选`a[i]`，`1`表示选择`a[i]`，同理`b[j]`也可以这样表示，因此集合的划分如下图所示：

![image-20231102220419512](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231102220419512.png)

第一种情况：

`f[i, j] = f[i - 1, j - 1]`

第二种情况：

注意，在这里使用`f[i, j] = f[i - 1, j]`的含义，因为`f[i - 1, j]`的含义是一个字符串的前`i`个字母和第二个字符串的前`j`个字母中所有公共子序列的最长长度，这里算出最长长度的最长子序列是不一定包含`b[j]`的，而我们这里的子集所对应的子序列，除了出现在第一个字符串中的前`i - 1`个字符外还必须包括`b[j]`，因此跟我们这里的子集的定义是不同的，但是`f[i - 1, j]`这个变量对应的集合一定包含了这个子集，所以在这里完全可以用`f[i - 1, j]`这个变量对应的集合替换掉上图中的子集

第三种情况：

同第二种情况，用`f[i, j - 1]`替换掉上图中的子集，因此第二，第三种情况我们其实是将两个子集扩大了，当四种情况考虑完全时，四个子集虽然有些数据重复，但是没有漏掉`f[i, j]`对应集合中的任意一个元素，因此我们计算四个子集的最大值，也就计算出来了`f[i, j]`，而且显然，第一种情况的子集包含在了第二中情况或者第三种情况的子集中

第四种情况：

`f[i, j] = f[i - 1, j - 1] + 1`，显然大于第一种情况

所以递推公式如下：

`f[i, j] = max(f[i - 1, j], f[i, j - 1], f[i - 1, j - 1] + 1)`

**集合存在问题：**

需要注意的是，当`a[i] != b[j]`的时候上述集合中的第四种情况是不会出现的，因此需要对`a[i]`和`b[j]`是否相等分情况讨论，存在性问题，使用`if`语句

**代码实现：**

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1010;

int n, m;
char a[N], b[N];
int f[N][N];

int main(){
    cin >> n >> m;
    
    scanf("%s%s", a + 1, b + 1);
    
    for(int i = 1; i <= n ; i ++){
        for(int j = 1; j <= m; j ++){
            f[i][j] = max(f[i][j - 1], f[i - 1][j]);
            if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
            
        }
    }
    
    cout << f[n][m];
    
    return 0;
}
```

**时间复杂度：**`O(n^2)`

**边界问题：**

边界也就是`f[i][j]`这个二维矩阵的最上方和最左方的边界，可以验证边界放在上面的循环中是计算正确的，边界正确，按照递推公式，也就求出了所有的正确值



## 线性DP - 最短编辑距离

![image-20231105164942869](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231105164942869.png)

**状态表示：**

变量维度：用一个二维变量`f[i, j]`

变量集合：使得`word1[1...i]`的与`word2[1...j]`匹配，不同方案的操作次数构成的集合

变量属性：使得`word1[1...i]`的与`word2[1...j]`匹配所需的最小操作次数

**集合划分与状态计算：**

一般是考虑最后一步的不同来对集合进行划分

这个可行解集就是使得`word1[1...i]`的与`word2[1...j]`匹配的各种方案对应的操作次数的集合，且任意一种方案一定会对字符的末尾进行操作，我们要求的值`f[i][j]`就是这些方案中的最小操作次数，注意方案的操作次数与方案的顺序是无关的

>  比如使得`abxcj`与`ebc`相匹配的话我们可以先加上`e`，然后按序去掉`a x j`，也可以先按序去掉`a x j`，然后再加上`e`，所以不管怎样，对于两个方案来讲，**只要两个方案中操作类型是一样的，那么这两个方案的操作次数是与操作顺序是无关的，这两个方案可以看作是一个方案**

所以上述集合中不同方案的差别仅仅在于操作的类型不同，因此我们可以以对最后一个字符进行的操作进行子集划分

1. 最后一步增操作，就是先将`word1[1....i]`与`word2[1....j - 1]`匹配好，然后再加上这个字符，所以这个子集的最小值就是`f[i][j - 1] + 1`

2. 最后一步删操作，就是先将`word1[1....i - 1]`与`word2[1....j]`匹配好，然后删去最后一个字符，所以这个子集的最小值就是`f[i - 1][j] + 1`

3. 最后一步改操作，就是先将`word1[1....i - 1]与word2[1....j - 1]`匹配好，然后改最后一个字符，所以这个子集的最小值就是`f[i - 1][j - 1] + 1`

三者取小可得：`f[i][j] = min(f[i][j - 1] + 1, f[i - 1][j] + 1, f[i - 1][j - 1] + 1)`

**集合存在问题：**

两个字符串的最后一个字符如果一样的话变量对应的可行解集是不一样的，因此分类讨论如下

若`word1[i] = word2[j]`

`f[i][j] = f[i - 1`][j - 1]

若`word1[i] != word2[j]`

`f[i][j] = min(f[i][j - 1] + 1, f[i - 1][j] + 1, f[i - 1][j - 1] + 1)`

**代码实现：**

```cpp
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1010;

int n, m;

char a[N], b[N];
int f[N][N];

int main(){
    
    //递推公式涉及i - 1，因此字符下标从1开始
    scanf("%d%s", &n, a + 1);
    scanf("%d%s", &m, b + 1);
    
    //处理边界问题a中有零个字符的时候全部为添加操作
    for(int i = 0; i <= m; i ++) f[0][i] = i;
    
    //处理边界问题b中有零个字符的时候全部为删除操作
    for(int i = 0; i <= n; i ++) f[i][0] = i;
    
    //从1开始递推
    for(int i = 1; i <= n; i ++){
        for(int j = 1; j <= m; j ++){
            if(a[i] == b[j]){
                f[i][j] = f[i - 1][j - 1];
                continue;
            }
            f[i][j] = min(f[i][j - 1] + 1, f[i - 1][j] + 1);
            f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1);

        }
    }
    cout << f[n][m];
    return 0;
}
```

**时间复杂度：**

`O(n^2)`

## 区间DP - 石子合并

![image-20231104183718825](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231104183718825.png)

**状态表示：**

状态维度：一个二维变量，`f[i, j]`

状态集合：将第`i`堆石子到第`j`堆石子合并成一堆的所有方法对应的代价构成的集合

状态属性：集合的最小值，所有方法中的代价的最小值，最后的答案就是`f[1, n]`

**集合划分与状态计算**

可以想到，从第`i`个合并到`j`个最后一定是两堆石子进行合并，那么我们可以以最后一次合并的位置来分类，比如先合并`i...m`堆石子然后再合并`m + 1, ...j`堆石子，最后将这两堆石子合并成一堆，可以以`m`的取值进行划分，`m`取为`i...j`，于是，我们以`i...m`有多少堆来划分集合，如下图所示，`k`表示`i...j`中石子的堆数，为`j - i + 1`：

![image-20231104185108699](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231104185108699.png)

先合并`[i, m]`，然后再合并`[m + 1, j]`，因为所有的子集都需要最后一步的合并，这个代价是一个定值，就是`[i...j]`所有石子堆的总质量，因此某个子集的最小值就是合并`[i, m]`的最小代价加上合并`[m + 1, j]`的最小代价，所以递推公式如下：

`f[i, j] = Min(f[i, m] + f[m + 1, j] + M) `，`m`的取值为`i.....j-1`

 因为`M`其实是`[i...j]`的和，也就是前缀和，所以`M`可以用`s[j] - s[i - 1]`计算出来，这里`s[j]`表示的是`[1....j]`的所有堆的石子的和，所以递推公式为：

`f[i, j] = Min(f[i, m] + f[m + 1, j] + s[j] - s[i - 1]) `，`m`的取值为`i.....j-1`

**代码实现：**

```cpp
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 310;

int n;
int s[N];//前缀和
int f[N][N];

int main(){
    scanf("%d", &n);
    //先读取每一堆的质量
    for(int i = 1; i <= n; i ++) scanf("%d", &s[i]);
    
    for(int i = 1; i <= n; i ++) s[i] += s[i - 1];
    
    //对于这样的区间DP，不能像普通那样按顺序从左到右，从上到下枚举计算
    //一般而言区间DP从枚举区间的长度开始
    //先将这个长度的区间算完，然后计算下一个长度的区间
    //这样可以保证计算长度长的区间时使用的长度短的区间已经被计算出来了
    
    //枚举区间长度
    for(int len = 1; len <= n; len ++)
        //枚举这个区间长度的区间
        for(int i = 1; i + len - 1 <= n; i ++){
            int l = i;//左端点
            int r = i + len - 1;//右端点
            f[l][r] = 1e10;
            if(len == 1) f[l][r] = 0;//如果区间的长度为1，合并时不需要代价
            
            //枚举分界点，计算这个区间的最小值
            for(int m = l; m < r; m ++) 
                f[l][r] = min(f[l][r], f[l][m] + f[m + 1][r] + s[r] - s[l - 1]);
        }
        
        cout << f[1][n] << endl;
    
    
    return 0;
}
```

**时间复杂度：**

不难看出为`O(n^3)`

**一些注意事项：**

 区间DP一般的暴力做法计算顺序就是枚举区间的长度，从小到大枚举长度，然后枚举区间，然后枚举决策
