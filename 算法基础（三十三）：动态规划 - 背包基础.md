# 算法基础（三十三）：动态规划 - 背包基础

## 完全背包问题

![image-20231002124337535](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231002124337535.png)

### 状态表示

我们用`f[i, j]`来表示选前`i`个物品且总体积不大于`j`的最大价值，那么这个变量对应的集合就是选前`i`个物品且总体积不大于`j`的所有选法对应的价值

### 集合划分与状态计算

我们考虑第`i`个物品，将上述的集合划分为选`0`个，选`1`个，....选`k`个（不超过总的体积），如下图所示：

![image-20231002162102320](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231002162102320.png)

那么我们选出这些子集中的最大值然后比较选出最大值即可

1. 选`0`个的子集的最大价值是：`f[i - 1][j]`（不选第`i`个，只考虑`i - 1`个物品且体积不超过`j`的最大价值）
2. 假设第`i`个物品选了`m`个其对应的价值是：`m * w[i]`，那么还剩下前`i - 1`个物品且体积还剩下：`j - m * v[i]`，要求的是选了第`i`个物品`m`个时的价值最大，也就要求在体积为`j - m * v[i]`情况下选择前`i - 1`个物品得到的价值最大所以这种情况的子集的最大值就是：`f[i-1, j - m * v[i]] + m * w[i]`

其实上面两种情况可以综合起来，得到的递推公式就是：`f[i, j] = max(f[i - 1, j - m * v[i]] + m * w[i])`其中`m`的取值是`0 ~ k`（k不能无限大）

### 代码实现

朴素做法，这种做法的复杂度较高，第三重循环最坏的情况下`v[i] = 1`需要循环`j`次，所以三重循环最坏需要循环`n*m*m`次，也就是题中的`N * V * V`次：

```c++
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1010;

int n, m;
int v[N],w[N];
int f[N][N];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i ++)
        for(int j = 0; j <= m; j ++)
            for(int k = 0; k * v[i] <= j; k ++)
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);
    
    cout << f[n][m];
    
    return 0;
                
}
```

### 代码优化

我们来再次查看上述的递推公式：

$f[i, j] = max(f[i - 1, j], f[i - 1, j - v[i]] + w[i], f[i - 1, j - 2*v[i]] + 2*w[i], f[i - 1, j - 3*v[i]] + 3*w[i])......$

再看$f[i, j - v[i]]$

$f[i, j-v[i]] = max(f[i - 1, j -v[i]), f[i - 1, j-2*v[i]]  + w[i], f[i - 1, j-3*v[i]]  + 2*w[i])......$

可以看到，`f[i, j]`与`f[i, j - v[i]]`相比，在`f[i - 1, j - m*v[i]]`相同的时候`f[i, j]`对应的相多加了一个`w[i]`

推导如下：
$$
f[i, j] = \\
max(f[i - 1, j], f[i - 1, j - v[i]] + w[i], f[i - 1, j - 2*v[i]] + 2*w[i], f[i - 1, j - 3*v[i]] + 3*w[i])...... =\\
max(f[i - 1, j], max(f[i - 1, j - v[i]] + w[i], f[i - 1, j - 2*v[i]] + 2*w[i], f[i - 1, j - 3*v[i]] + 3*w[i])......)) = \\
max(f[i - 1, j], max(f[i - 1, j - v[i]], f[i - 1, j - 2*v[i]] + w[i], f[i - 1, j - 3*v[i]] + 2*w[i])......) + w[i]) = \\
max(f[i - 1][j], f[i, j -v[i]] + w[i])
$$
因此代码可以优化如下：

```c++
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1010;

int n, m;
int v[N],w[N];
int f[N][N];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i ++)
        for(int j = 0; j <= m; j ++){
            f[i][j] = f[i - 1][j];
            if(j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
        }
    
    cout << f[n][m];
    
    return 0;
                
}
```

从上方的集合的图来理解这里的代码就是在优化后的代码中直接用`f[i][j -v[i]] + w[i]`来整合了选取第`i`个物品大于`1`的这些所有的子集，其实划分集合的时候就可以用选择第`i`个物品，不选择第`i`个物品来进行划分集合，这里的时间复杂度就是`O(n*m)`

同样，完全背包问题可以继续进行优化成一维数组：

```c++
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1010;

int n, m;
int v[N],w[N];
int f[N];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i ++)
        for(int j = v[i]; j <= m; j ++)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    
    cout << f[m];
    
    return 0;
                
}
```

注意完全背包的递推公式是`f[i, j] = max(f[i - 1][j], f[i, j -v[i]] + w[i]) `

01背包的递推公式是`f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])`

可以看到完全背包使用是上一层的`f[i -1][j]`以及当前层的`f[i, j -v[i]]`来计算，01背包使用的两个都是上一层的，所以当优化到一维的时候完全背包不能从右往左遍历，而01背包必须从右往左遍历

## 多重背包问题

![image-20231009202754805](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231009202754805.png)

### 状态表示

我们用`f[i, j]`来表示选前`i`个物品且总体积不大于`j`的最大价值，那么这个变量对应的集合就是选前`i`个物品且总体积不大于`j`的所有选法对应的价值

### 集合划分与状态计算

这里跟完全背包问题的集合划分几乎一样，将这个集合划分为选择`1， 2， 3 ....s[i]`个

![image-20231009203654515](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231009203654515.png)

因此这个状态转移方程的朴素版本就是：`f[i, j] = max(f[i - 1, j - v[i] * k] + w[i] * k)`，`k`从`0`取到`s[i]`

### 代码实现

```c++
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 110;
int n, m;
int f[N][N];
int v[N], w[N], s[N];

int main(){
    cin >> n >> m;
    
    for(int i = 1; i <= n; i ++) cin >> v[i] >> w[i] >> s[i];
    
    for(int i = 1; i <= n; i ++)
        for(int j = 0; j <= m; j ++)
            // 枚举第i个物品可以选择多少个
             for(int k = 0; k <= s[i] && k * v[i] <= j; k ++)
             //i = 1的时候f[0][j] = 0，此时计算的f[1][j]的最大值符合我们的定义，不用考虑边界的情况
                f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
    
    cout << f[n][m] << endl;
    
    return 0;
}
```

### 代码优化（二进制优化，包含非常详细的证明）

如果将数据提升到`1000`可以看到计算的规模就变成了一个亿级别，这时显然超时了，所以我们得考虑进行优化

与完全背包问题相似的思考方式：

`f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2v] + 2w,...,f[i - 1][j - vs] + sw)`

`f[i][j - v] = max(        f[i - 1][j - v], f[i - 1][j - 2v] + w,...,f[i - 1][j - vs] + (s-1)w) + f[i - 1][j - v(s+1)] + sw)`

我们可以知道`f[i][j - v]`的值（总体的最大值），也可以知道`f[i - 1][j - (s + 1)v] + sw`的值（末尾的最大值）但是却求不出来前面项的最大值所以也就无法求出`f[i][j]`后面项的最大值，所以也就不能按照完全背包的思考方式去思考，因此我们得思考其他的优化方式

在这里考虑一种多重背包的经典优化方式，这种优化方式将多重背包问题转换成了一个`01`背包问题，从而将第三维的复杂度降低，我们首先介绍一种对原来物品的划分方式：

首先，我们考虑一个物品`a`，假设它有`s`个，接下来，我们使用一种划分方式将这`s`个物品分成$1, 2, 4,8...2^{n},C$这`(n + 2)`个堆，同时这些堆的数量满足以下性质：

1. 前`n + 1`堆第`m`堆的物品`a`的数量是$2^{m - 1}$个，也就是以二进制的形式划分这`s`个物品`a`
2. 这些数的和保证$1+2+4+8+...+2^{n}+C = s$
3. $2^n$是最后一个不大于`s`的二进制数，即$2^{n + 1} > s$
4. 由性质3可以得到$C <2^{n+1} - 1$且$1+2+4+8+...+2^{n} = 2^{n+1} - 1$

对于物品`a`我们进行如上的划分，对于每一堆我们将其看作一个新的物品，第`m`堆这个新的物品的体积就是$2^{m - 1} * v[a]$，第`m`堆这个新的物品的价值就是$2^{m - 1} * w[a]$

对于多重背包问题的所有物品都进行上面的划分，并将所有物品划分得到的堆看作新的物品，如下图所示，简单起见，最上方的一行数字表示多重背包的物品编号，同时也表示体积和价值，其重复的个数表示这个编号的物品有多少个，中间一行表示新划分的堆的总体积和价值，最下方表示新划分的物品的编号：

![image-20231012212308605](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231012212308605.png)

假设原来的背包的总体积为`V`，我们对新的物品进行`01`背包求解得到最优价值`W2`，直接对原来的物品进行多重背包问题的朴素版本求解得到最优价值为`W1`，下面来证明必然有`W1 = W2`：

我们用`Mvalue[3, V]`表示`3`个旧物品，背包体积不超过`V`的情况下，多重背包问题中不同物品选法对应的价值集合，用`01value[10, V]`表示`10`个新物品，背包体积不超过`V`的情况下，`01`背包问题中不同选法对应的价值集合。如果我们能证明`Mvalue[3, V] = 01value[10, V]`，那么显然，对应问题求解得到的价值的最大值也必然有`W1 = W2`

首先，在多重背包问题中，对于一个物品`a`，假设它有`s`个，还记得上面的划分规则吗，我们以二进制的形式对其进行划分，将这`s`个物品分成$1, 2, 4,8...2^{n},C$​这`(n + 2)`个堆，同时这些堆的数量满足以下性质：

1. 前`n + 1`堆第`m`堆的物品`a`的数量是$2^{m - 1}$个，也就是以二进制的形式划分这`s`个物品`a`
2. 这些数的和保证$1+2+4+8+...+2^{n}+C = s$
3. $2^n$是最后一个不大于`s`的二进制数，即$2^{n + 1} > s$
4. 由性质3可以得到$C <2^{n+1} - 1$且$1+2+4+8+...+2^{n} = 2^{n+1} - 1$

首先，$1, 2, 4,8...2^{n}$这些数，可以凑出$0 - 2^{n + 1} - 1$中的任意一个数，你可以将这个范围内的数用二进制表示，可以发现任何一个数它每一位二进制的`1`总是可以从这些堆中挑出来表示，也就当然可以表示这个范围中的任意一个数

再考虑$1, 2, 4,8...2^{n},C$这些数，在前面的这些数中多了一个$C$，所有这些数加起来可以表示的最大值显然是`s`，而`C`之前的这些数凑出来的范围是$0 - 2^{n + 1} - 1$，因此这个范围任何一个数加上$C$之后可以凑出的范围是$C - s$，因此$1, 2, 4,8...2^{n},C$这些数可以凑出的范围就是$0 - 2^{n + 1} - 1$和$C - s$，而由于上面的性质4，所以我们就可以得到这样一个结论：

对于一个物品`a`，假设它有`s`个，按照我们的二进制规则划分得到个数分别为$1, 2, 4,8...2^{n},C$这`(n + 2)`个堆，并且这些堆总可以凑出`0 ~ s`这个范围中的任意一个数

因此，对于旧的多重背包中某个物品`a`，假设其有`s`个，他的某种选法，假设选了`k`个`a`，因为`0 < k < s`，所以我们总可以在新划分得到的`01`背包问题中找到对应的一个选法，使得使得这个选法对应的`a`的数量也是`k`也就是体积以及价值与旧的选法完全相同，比如在上图中，我们在多重背包中选择了`4`个`2`号物品，对应的价值和体积是`8`，而在下方新划分的`01`背包问题中，我们直接选择`6`号物品（是`4`个`2`号物品形成的堆），`4, 5`不选，就得到了相同的价值和体积，多重背包问题中的`1`号和`2`号物品的选法也是同理

因此对于多重背包问题的每一种选法对应的价值和体积，在新划分的`01`背包中都可以找到完全一样的价值和体积对应的选法

那么反过来，对于`01`背包的任何一种选法对应的价值和体积，我们都可以在多重背包中找到一个选法使得价值与体积相同，这个比较显然，因为本来`01`背包就是多重背包堆起来的，我们将`01`背包的这个选法拆开就是多重背包了

因此就证明了划分前后的两个问题的选法价值集合完全等价，也就是`Mvalue[3, V] = 01value[10, V]`，那么显然两种问题求得的最大价值就有`W1 = W2`，因此我们也就证明了这种划分转换方式的正确性

### 优化版本的代码实现

![image-20231012223256045](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231012223256045.png)

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

//N的数量级开到2000 * log(2000)，表示总的物品的个数
const int N = 25000, M = 2010;
int n, m;
int v[N], w[N];
int f[N];
int main(){
    cin >> n >> m;
    int cnt = 0;
    //遍历每一个物品
    for(int i = 1; i <= n; i ++){
        int a, b, s;
        // 读入当前物品的体积，价值和个数
        cin >> a >> b >> s;
        //对这s个物品进行划分
        //k用来控制二进制的幂
        int k = 1;
        while(k <= s){
            cnt ++;
            //构造新的物品的体积
            v[cnt] = a * k;
            w[cnt] = b * k;
            //s减去k
            s -= k;
            //k乘以2
            k *= 2;
        }
        //如果这个物品最后还有大于0的C
        //补上物品i的最后一堆
        if(s > 0){
            cnt ++;
            v[cnt] = s * a;
            w[cnt] = s * b;
        }
    }
    
    //将n赋值为cnt, 此时的cnt是新划分的堆构成的物品的最后一个物品的编号
    n = cnt;
    //01背包问题的物品编号0 ~ n
    //开始进行01背包问题处理
    for(int i = 0; i <= n; i ++)
        for(int j = m; j >= v[i]; j --)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
            
    cout << f[m] << endl;
    return 0;
}
```

至于时间复杂度，一个物品的个数是`si`个，划分了`log(si)`个`01`背包中的物品，所以`01`背包中的总的物品个数最大是`N * log(si(max))`个，因此总的时间复杂度最高是`N * M * log(si(max))`个，按照题目中的数量级，复杂度最高是`2000 * 1000 * log(2000)`，因此时间复杂度可控

 

## 分组背包问题

![image-20231016193254983](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231016193254983.png)

### 状态表示

使用`f[i, j]`表示只从前`i`组物品中选择并且总体积不大于`j`的所有的选法对应的价值中的最大值

### 集合划分与状态计算

在多重背包问题中我们在划分集合的时候是枚举第`i`个物品取了多少个，在分组背包中我们可以枚举取第`i`组哪一个物品，因此划分如下所示：

1. 不取第`i`组的物品，此时有`f[i, j] = f[i - 1, j]`
2. 取第`i`组的第`k`个物品，此时有`f[i, j] = f[i - 1, j - v[i, k]] + w[i, k]`

![image-20231016195848342](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231016195848342.png)

### 代码实现

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 110;

int n,m;

//s[N]存放每一组的个数
int v[N][N], w[N][N], s[N];
int f[N];

int main(){
    
    //读取数据
    cin >> n >> m;
    for(int i = 1; i <= n; i ++){
        cin >> s[i];
        for(int j = 0; j < s[i]; j ++){
            cin >> v[i][j] >> w[i][j];
            
        }
    }
    
    //从前往后枚举每一组物品
    for(int i = 1; i <= n; i ++){
        //从大到小枚举体积
        for(int j = m; j >= 0; j --){
            //枚举所有的物品的选择
            for(int k = 0; k < s[i]; k ++){
                //如果第k个物品的体积大于此时的背包容积，直接跳过，这时集合对应的值为0
                if(v[i][k] > j) continue;
                else f[j] = max(f[j], f[i, j - v[i][k]] + w[i][k]);
            }
        }
    }
    cout << f[m];
    return 0;
}

```

