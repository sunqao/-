# 算法基础（三十五）：动态规划 - 计数DP

## 整数划分问题

![](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231105201830409.png)

### 完全背包做法

可以看作是一个背包的容量是`n`，然后有`n`个物品，对应的重量分别是`1 2 3 ....n`，且物品的个数无限，求装满背包的物品选择方案数

因为上述题目中整数`n`的任意一个划分的方案，都可以对应这个背包问题的选法，反之亦然，因此两种做法等价

**变量表示：**

变量维度：一个两维变量`f[i, j]`

变量对应集合：所有从`1 ~ i`中选择并且体积为`j`的选法构成的集合

变量属性：集合中元素的个数

**集合划分与状态计算：**

跟完全背包问题的划分方式一样，对当前物品`i`选了多少个进行划分：

`0`个：`f[i, j] = f[i - 1, j]`

`1`个：`f[i, j] = f[i - 1, j - i]`

`2`个：`f[i, j] = f[i - 1, j - 2 * i]`

...

`s`个：`f[i, j] = f[i - 1, j - s * i]`

最后加起来即可，这里就不写代码了

**集合存在性问题：**

1. 如果`j < i`的话解集只有选`0`个这一个子集，后面再选择物品`i`不再考虑
2. 选择物品`i`的时候需要考虑`s * i`与`j`的大小关系

**时间复杂度：**

一共最多`n^2`个状态，最后的时间复杂度看似是`n^3`，但是再仔细分析一下

```cpp
for(int i = 1; i <= n; i ++)
    for(int j = 1; j <= n; j ++)
        if(j < i) f[i][j] = f[i - 1][j];
		else{
            for(int s = 1; s * i < j; s ++)
                f[i][j] += f[i - 1][j - i * s];
        }
```



当计算`f[i, j]`的时候，需要计算最多$\frac{j}{i}$次，最外层`i`固定循环`j`的时候计算的次数是$\Sigma_{j = 1}^{n} \frac{j}{i} = \frac{1}{i}(1 + 2 + ...n)$

再进行最外层的循环得到总的计算次数为$(1 + 2 + ...n)\Sigma_{i = 1}^{n} \frac{1}{i}$

最后的复杂度应该是`O(n^2logn)`

**代码优化：**

`f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2i] + ..... + f[i - 1][j - i * s]`(s是满足i*s <= j的最大值)
`f[i][j - i] = f[i - 1][j - i] + f[i - 1][j - 2i] + ..... + f[i - 1][j - i * s] `

因此可以优化为`f[i][j] = f[i - 1][j] + f[i][j - i]`

同时可以去掉第一维得到：`f[j] = f[j] + f[j - i]`

枚举体积的时候从小到大进行循环，这样等式右边的`f[j]`还未更新，值是上一层的`f[i - 1][j]`，且等式右边的`f[j - i]`用的是更新过的值也就是本层的`f[i][j - i]`

**优化版本代码实现：**

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1010, mod = 1e9 + 7;

int n;
int f[N];

int main(){
    cin >> n;
    //初始化第0层
    f[0] = 1;//其实就是f[0][0], 整数为0的时候0个物品有一个方案
    //其他的第一层整数不为0但是0个物品，没有方案
    for(int i = 1; i <= n; i ++) f[i] = 0;//其实是f[0][i]
    
    //开始递推
    for(int i = 1; i <= n; i ++)
        for(int j = i; j <= n; j ++)
            // if(j < i) f[j] = f[j];//如果j < i的话，i一定不能选
            // else f[i][j] = max(f[i][j], f[i][j - i]);
            f[j] = (f[j] + f[j - i]) % mod;
            
    cout << f[n];
    return 0;
}
```

优化版本的时间复杂度就是`O(n^1)`

### 另外一种做法

**变量表示：**

变量维度：一个二维变量`f[i, j]`

变量对应集合：所有总和是`i`，并且恰好表示成`j`个数的和的方案

变量属性：集合中元素，也就是所有方案的个数

**集合划分与状态计算：**

我们这样对集合进行划分，一个是`j`个数中最小值为`1`的方案构成的子集，一个是`j`个数最小值大于`1`的方案构成的子集，如下图所示

![image-20231106072600156](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20231106072600156.png)

最小值为`1`的的子集：

每种方案把`1`去掉，就变成了和是`i - 1`，恰好表示成`j - 1`个数的方案，反过来，任意一个和是`i - 1`，恰好表示成`j - 1`个数的方案，加上一个`1`之后变成了和是`i`，并且恰好表示成`j`个数的和的方案，因此这个子集中的元素与和是`i - 1`，恰好表示成`j - 1`个数的方案构成的子集中的元素一一对应，因此这个子集的元素个数为`f[i - 1, j - 1]`

最小值大于`1`的子集：

对于这个子集中的某个方案的`j`个数，每个数都减`1`就变成了和是`i - j`，恰好表示成`j`个数的方案，同上面的分析，这个子集与`f[i - j, j]`这个集合中的数一一对应，因此这个子集的元素个数为`f[i - j, j]`

所以有`f[i, j] = f[i - 1, j - 1] + f[i - j, j]`

注意上面分析中只有方案中的数字如果考虑数字的排列就不满足满足这样的一一映射了，比如`f[4, 2]`如果考虑顺序的话有三个方案`1 3, 3 1, 2 2`，含有`1`的方案去掉`1`后为`3, 3`,但是`f[3, 1]`对应的集合中元素只有一个，即：考虑排列顺序 => 不满足映射，而我们在这里使用满足映射的规则计算，根据逆否关系，从而计算的结果就是不考虑排列顺序的

**代码实现：**

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1010, mod = 1e9 + 7;

int n;

int f[N][N];

int main(){
    
    cin >> n;
    //和为0，恰好为0个数的方案有一个
    f[0][0] = 1;
    
    for(int i = 1; i <= n; i ++)
    //i最多表示成i个数的和，因此后面的数都没有意义了，不用计算
        for(int j = 1; j <= i; j ++)
            f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod;
    
    int res = 0;
    
    for(int i = 1; i <= n; i ++) res = (res + f[n][i]) % mod;
    
    cout << res;
    
    return 0;
    
}
```

时间复杂度`O(n^2)`
